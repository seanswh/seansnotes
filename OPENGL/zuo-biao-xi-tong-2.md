### 局部空间\(local space\)

局部空间就是你创建的物体开始的地方，也就是相对于物体的坐标系。你创建的立方体的原点有可能位于\(0，0，0\)，即使有可能在最后的应用中位于完全不同的另外一个位置。甚至有可能你创建的所有模型都以\(0，0，0\)为初始位置，然而他们会在世界的不同位置。则你的模型的所有顶点都是在**局部**空间：他们相对于你的对象来说都是局部的。

### 世界空间\(world space\)

世界空间\(World Space\)中的坐标就如它们听起来那样：是指顶点相对于\(游戏\)世界的坐标。物体变换到的最终空间就是世界坐标系，并且你会想让这些物体分散在世界各地\(从而显得更真实\)。模型矩阵\(model matrix\)就是负责将对象的坐标从局部空间变换到世界空间中的。

模型矩阵是一种转换矩阵，它能将对象进行平移、缩放、旋转从而将它置于它本应该在的位置或方向。你可以想象一下，我们可以转换一栋房子，通过将它缩小\(因为它在局部坐标系中显得太大了\)，将它往郊区的方向平移，然后沿着y轴往坐标旋转，经过一系列的操作，这个方式最终和他的邻居完美的匹配上了。之前讲的变换就是模型矩阵的一种应用——我们将箱子的局部坐标转换成了世界坐标。

### 观察空间\(view space\)

观察空间也就是OPENGL所说的相机空间\(camera space\)。观察空间就是将对象的世界空间的坐标转换为观察者视野的坐标。观察空间就是从摄像机的角度观察到的空间。而这通常是由一系列的平移和旋转的组合来平移和旋转场景从而使得**特定的对象被转换到摄像机前面\(**移动相机的操作和移动场景的操作其实是互为相反操作**\)**。这些组合在一起的转换通常存储在一个**观察矩阵\(View Matrix\)**里，用来将世界坐标转换到观察空间。

### 裁剪空间\(clip space\)

在顶点着色器的最后，OPENGL希望所有的坐标都能在一个指定的范围内，超出该范围的顶点将不会被绘制，剩下的顶点坐标最终会以片元的方式出现在屏幕上。

因为-1到1的范围不是很直观，所以我们会使用我们自己的坐标系来进行工作，最后转换回标准设备坐标系\(NDC\)。

我们使用了一个所谓的“投影矩阵”将观察空间\(view space\)中的坐标转换成裁剪空间，该矩阵可以指定坐标系的范围，比如每一个坐标系范围都设置到-1000和1000之间。然后投影矩阵会将该范围内的坐标都转换成-1到1之间的NDC坐标。在这个范围之外的坐标将会被裁剪下去。

> 注意：如果图像\(如三角形\)中只有一部分超出了裁剪体\(clipping volume\),OPENGL 会重构这个形状，将一个三角形重构成多个，以绘制裁剪区域内的形状。

由投影矩阵创建的**观察区域\(Viewing Box\)**被称为**平截头体\(Frustum\)**，且每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将一定范围内的坐标转化到标准化设备坐标系的过程\(而且它很容易被映射到2D观察空间坐标\)的全部过程被称为**投影\(Projection\)**，因为使用投影矩阵能将3维坐标**投影\(Project\)**到很容易映射的2D标准化设备坐标系中。

一旦所有顶点被转换到裁剪空间，最终的操作——**透视划分\(Perspective Division\)**将会执行，我们会将位置向量\(区分于方向向量\)的x,y,x分量除以齐次分量w，透视划分将4维裁剪空间坐标转换为3维标准化设备坐标。这一步会在每一个顶点着色器运行的最后被自动执行。

在这一阶段之后，坐标经过转换的结果将会被映射到屏幕空间\(可由`glViewport函数中的参数`设置,这一步被称为视口变换\(Viewport Transform\)\),最终，各个坐标会被转换成片段。

投影矩阵将观察坐标转换为裁剪坐标的过程采用两种不同的方式，每种方式分别定义自己的平截头体\(frustum\)。我们可以创建一个正射投影矩阵\(Orthographic Projection Matrix\)或一个透视投影矩阵\(Perspective Projection Matrix\)。

