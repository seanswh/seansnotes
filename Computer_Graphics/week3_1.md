Week3 Ray Trace  
    光线追踪是一个进行图像合成的方法，  
但它与OpenGL中的标准光栅化管线完全不同。我们逐像素而不是逐物体进行处理。光栅化（rasterizer）处理的是每个物体，它确定屏幕中的哪些像素与物体相对应，并作出相应的操作。而一个光线追踪器（raytracer）逐像素进行操作。对于每一个像素，它找到最近的物体并着色。光线追踪的一个优势是它很容易计算类似于阴影和透明等效果，而这些在OpenGL中很难处理。

光线追踪在过去发展很慢，但是近年来，我们看到它已变为实时的，并且得到了图形硬件的支持。关于研究我再说几句。光线追踪现在已进入了实时技术的主流。现在，NVIDIA的OptiX包括一个实时的光线追踪器。

![](/Computer_Graphics/images/42.PNG)上图是一个光线追踪器的“伪代码”，这个光线追踪函数。注意该函数的输入。有一个摄像机，有场景，图像的宽和高。所以这就是图像的宽和高。然后你就生成了一幅指定宽和高的新图像，接着你逐像素进行处理。所以这些循环对应像素。光线追踪，一定要记住它是逐像素处理的，计算出各像素应该绘制什么颜色。

让我们思考一下光栅化和光线追踪的区别。在光线追踪中，你先遍历像素。所以这是个对像素的for循环。然后你遍历各个物体，当然你事先并不知道哪个物体对应哪个像素，因此你需要遍历所有的物体，尽管到后面我们会发现使用加速结构可以使大大提高这个步骤的效率。在光栅化中，你先遍历场景中的所有物体，然后对每个物体，要找到你需要考虑的像素。但是你不用考虑所有的像素，你只要考虑对应于物体的那些像素，也就是那些真正在物体上的像素。

现在我们知道了为什么光线追踪在过去非常慢。你需要考虑所有的像素和所有的物体，因此总耗费是像素数乘以物体数。然而在光栅化中，你依然需要考虑所有的物体，但是需要考虑的像素的数目仅仅是那些物体覆盖的，可能只有10或20。

让我们继续讲解基本的光线投射算法：



