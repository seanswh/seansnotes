(1)正交投影和透视投影
首先，我们正式地来考虑这个问题。你想要把一个三维空间投射到二维空间。这本质上就是投影的意思。一种显而易见的方法是得到三维空间中的3个坐标，丢弃其中一个来形成一个二维空间。
事实上正交投影从一个更高的层面来看，就是得到三维空间中的X、Y、Z坐标，然后丢弃Z坐标，于是你便得到了在屏幕上的X坐标和Y坐标。
在世界空间里有一个长方体，这就是那个长方体。你首先把那个长方体映射到中心，然后将它映射到一个单位立方体上。事实上，我们将要讨论的所有变换，gluOrtho、gluPerspective本质上都是计算世界坐标系下的某个区域到单位立方体的映射。当然，
你可以说这个映射仍然是三维的，它有什么用？但我们基于的想法是一旦我们把它映射到单位立方体后，我们可以简单地丢弃Z坐标，在XY平面上看它。
![](/Computer_Graphics/images/18.png)
你需要做的几个步骤，首先使立方体居于中心，然后调整尺度使其变成一个单位立方体。我们可以为每一步推导一个变换矩阵。平移可以做到这一点，考虑中心的位置，等于(l + r) / 2。所以平移量应该是它的负数，来把它挪到中间。类似地，对于上裁剪面和下裁剪面，你可以得到，- (t + b) / 2。对于近裁剪面和远裁剪面也是一样的。是 - (f + n) / 2。
下一个问题是缩放量，当然它与这个长度的逆有关。那么我们来看看变换矩阵的样子，缩放矩阵是 2 / (r - l)，2 / (t - b)，2 / (f - n)。注意缩放变换是第二步，第一步是平移。
![](/Computer_Graphics/images/19.png)
我们还剩下最后一步来得到glOrtho的公式。在OpenGL中有一个约定，即你的观察方向是-z轴方向。因此n和f都是负数。n比f近，所以它是一个比f小的负数。然而，当你给定参数的时候，你给定的n和f是正的。因此，在公式中，你需要用-n替换n，用-f替换f。最终，它使得矩阵的一个元素值变成了相反数。
![](/Computer_Graphics/images/20.png)
(2) 透视投影
它的几何结构就是现在展示的样子。这是你的屏幕，线AB会投射到线A'B'上。在世界坐标系中有一个点(x, y, z)被投射到某个位置(x', y', d)。问题是这个投射到的点的坐标是什么？显然，x'和y'的公式是类似的，我们仅仅讨论其中一个。假设屏幕距离眼睛的长度为d，世界坐标系空间中的物体距离眼睛的长度为z。所以边的比例应该是一样的，即 d / x' 等于 z / x，x'等于d * x / z。
![](/Computer_Graphics/images/21.png)
但是，在标准的矩阵中，我们没有办法用x或y来除以z。这就使可以使用齐次坐标，因为在非齐次化的时候，需要除以第4个坐标值。所以你可以生成一个矩阵来让第4个坐标值变成z。![](/Computer_Graphics/images/22.png)
现在，如果我把这个坐标非齐次化，你会看到，x会乘以d / z，y会乘以d / z，就像我们需要的那样。并且事实上，对于将要被丢弃的z坐标，如果你把它乘以 d / z，它就等于d，也就是一个常数。上述步骤实现了三维向二维的转变！这个常数表示的就是图像平面的位置。现在问题是，为什么有一个负号？同样是因为OpenGL中的约定，你是看向-z轴的。所以焦平面（成像平面）在-d的位置。
（3）gluPerspective
gluPerspective变换，它会适当地变换三维世界坐标系，来把物体放置到屏幕上。整个变换管线包括以下内容。首先，应用gluLookAt变换或等价的相机变换，然后应用观察或投影变换。
gluPerspective有4个参数，它们如何影响gluPerspective的变换矩阵？从根本上说，gluPerspective有一个视体（viewing frustum，也称视景体，视锥）。任何在近裁剪面前的物体都会被遮住。类似地，任何在远裁剪面后面的物体也都会被遮住。这就是定义近裁剪面和远裁剪面的原因。下一个参数是视野，它的定义相当明显。
![](/Computer_Graphics/images/23.png)事实上，这里画的是Y方向上的视野，X方向与Y方向上的视野可以不同。然后你有一个一定宽度width、一定高度height的屏幕。纵横比就是width和height的比例。
Y方向的视野和纵横比决定了X方向上和Y方向上的视野，zNear和zFar决定了视体。这是屏幕的俯视图，我们想要计算的是值theta和d。![](/Computer_Graphics/images/24.png)theta，它可以很简单地通过Y方向上的视野除以2求出，d等于什么呢？从我们想映射到单位立方体上的几何关系来看，这里是1个单位。根据三角公式我们知道，tan(theta)等于 1 / d，这就意味d等于cot(theta)。所以我们把d写作cot theta。
得到如下矩阵：
![](/Computer_Graphics/images/25.png)
我们需要改变这里下方的2×2的矩阵来使得近/远裁剪面被正确地映射。是为了使z能被正确地映射，所以我们并不关心x和y。我们仅仅关心z和w来映射近/远裁剪面，接下来我们来讨论它们。
通常，当我说到齐次坐标的时候，我指的是一个4维向量，x, y, z和w。然而，你也可以把一个单独的坐标值变为齐次坐标，比如现在的z。把Z和W单独摘出来，可以得到如下矩阵计算：![](/Computer_Graphics/images/26.png)
根据glu的定义，近端为n，远端为f，而且我们想要映射到一个单位立方体上，因此当z等于-f的时候，这个值应该为+1，z等于-n的时候，这个值为-1.